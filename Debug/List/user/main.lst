###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         20/Dec/2021  17:32:28
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Users\SEOYOUNG\Desktop\project\user\main.c
#    Command line                 =
#        -f C:\Users\SEOYOUNG\Desktop\project\Debug\Obj\user\main.o.rsp
#        (C:\Users\SEOYOUNG\Desktop\project\user\main.c -D USE_STDPERIPH_DRIVER
#        -D STM32F10X_CL -lC C:\Users\SEOYOUNG\Desktop\project\Debug\List\user
#        -o C:\Users\SEOYOUNG\Desktop\project\Debug\Obj\user --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\SEOYOUNG\Desktop\project\libraries\CMSIS\DeviceSupport\ -I
#        C:\Users\SEOYOUNG\Desktop\project\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\SEOYOUNG\Desktop\project\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\SEOYOUNG\Desktop\project\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\SEOYOUNG\Desktop\project\libraries\LCD\ -I
#        C:\Users\SEOYOUNG\Desktop\project\libraries\HC-SR04\ -I
#        C:\Users\SEOYOUNG\Desktop\project\user\ -I
#        C:\Users\SEOYOUNG\Desktop\project\user\inc\ -Ol -I "C:\Program
#        Files\IAR Systems\Embedded Workbench 9.0\arm\CMSIS\Core\Include\\" -I
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\CMSIS\DSP\Include\\") --dependencies=n
#        C:\Users\SEOYOUNG\Desktop\project\Debug\Obj\user\main.o.d
#    Locale                       =  C
#    List file                    =
#        C:\Users\SEOYOUNG\Desktop\project\Debug\List\user\main.lst
#    Object file                  =
#        C:\Users\SEOYOUNG\Desktop\project\Debug\Obj\user\main.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __size_limit               =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Users\SEOYOUNG\Desktop\project\user\main.c
      1          #include "stm32f10x.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable21
   \       0x14   0xB240             SXTB     R0,R0
   \       0x16   0x0940             LSRS     R0,R0,#+5
   \       0x18   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1C   0x4770             BX       LR
      2          #include "core_cm3.h"
      3          #include "misc.h"
      4          #include "stm32f10x_gpio.h"
      5          #include "stm32f10x_rcc.h"
      6          #include "stm32f10x_exti.h"
      7          #include "stm32f10x_usart.h"
      8          #include "stm32f10x_HC-SR04.h"
      9          
     10          
     11          /********************Current Specification********************
     12          
     13          * IR 센서 2개 사용 (좌측 경로 인식, 우측 경로 인식)
     14          * 1회 학습 운행 후 2회차 부터는 목적지 까지 직행 가능
     15          * BT를 통해 학습 운행, 정지, 운행 3가지 명령어 부여함 [인터럽트]
     16          * 적외선 센서로 근거리 (80mm)에 물체인식 시 일시 정지 [인터럽트]
     17          * 좌측 우측 IR 센서 동작시 차체 일시 정지 [인터럽트]
     18          
     19          *************************************************************/
     20          
     21          
     22          /**************************TODO List**************************
     23          
     24          * memory allocation 통해 선택지 확장
     25          
     26          *************************************************************/
     27          
     28          
     29          
     30          //돌아옴 1  없음 0

   \                                 In section .bss, align 4
     31          int waybackFlag = 0;
   \                     waybackFlag:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     32          int learningFlag = 0;
   \                     learningFlag:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     33          uint32_t dist = 0;
   \                     dist:
   \        0x0                      DS8 4
     34          
     35          
     36          //기본 방향 지시를 위한 enumeration
     37          enum Direction {UP, DOWN, LEFT, RIGHT, STOP};
     38          //현재 모터 이동 방향 지시용

   \                                 In section .data, align 1
     39          enum Direction state = STOP;
   \                     state:
   \        0x0   0x04               DC8 4
     40          
     41          //갈림길 선택지 기록용 구조체 
     42          typedef __packed struct pathPick{
     43              enum Direction direction;
     44              uint32_t visit;
     45          }pathPick;
     46          
     47          //갈림길 선택지 기록

   \                                 In section .bss, align 4
     48          pathPick visitPath[10];
   \                     visitPath:
   \        0x0                      DS8 52
     49          
     50          //적외선 센서 B1, C0, C2, C3, C4, C5 왼쪽[0]1 중간[1]2 오른쪽[2]3
     51          void USART1_Init(void);
     52          void USART1_IRQHandler(void);
     53          
     54          void USART2_Init(void);
     55          void USART2_IRQHandler(void);
     56          
     57          void sendDataUART1(uint16_t data);
     58          void sendDataUART2(uint16_t data);
     59          void setCMD(char);
     60          
     61          //블루투스용 명령어
     62          #define START   'S'
     63          #define HALT    'H'
     64          #define LEARN   'L'
     65          
     66          //미로 갈림길 최대 개수
     67          #define MAXCROSS 10
     68          

   \                                 In section .data, align 4
     69              char startup[] = "BTWIN Slave Mode Start";
   \                     startup:
   \        0x0   0x42 0x54          DC8 "BTWIN Slave Mode Start"

   \              0x57 0x49    

   \              0x4E 0x20    

   \              0x53 0x6C    

   \              0x61 0x76    

   \              0x65 0x20    

   \              0x4D 0x6F    

   \              0x64 0x65    

   \              0x20 0x53    

   \              0x74 0x61    

   \              0x72 0x74    

   \              0x00
   \       0x17                      DS8 1

   \                                 In section .data, align 4
     70              char startScan[] = "AT+BTSCAN";
   \                     startScan:
   \        0x0   0x41 0x54          DC8 "AT+BTSCAN"

   \              0x2B 0x42    

   \              0x54 0x53    

   \              0x43 0x41    

   \              0x4E 0x00
   \        0xA                      DS8 2
     71          

   \                                 In section .text, align 2, keep-with-next
     72          void RCC_Configure() {
   \                     RCC_Configure: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     73              /* UART TX/RX port clock enable */
     74              RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     75              // UART TX PA 9, RX PA 10
     76              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x2004             MOVS     R0,#+4
   \        0xE   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     77          
     78              /* USART2 clock enable datasheet에 보면 APB1을 사용함*/
     79              /*USART1 clock enable */
     80              RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0xF44F 0x4080      MOV      R0,#+16384
   \       0x18   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     81              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0xF45F 0x3000      MOVS     R0,#+131072
   \       0x22   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     82          
     83              //적외선 센서
     84              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0xF44F 0x7000      MOV      R0,#+512
   \       0x2C   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     85              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
   \       0x30   0x2101             MOVS     R1,#+1
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
     86          
     87              //PD 9,10,11,12
     88              RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); // interrupt
   \       0x38   0x2101             MOVS     R1,#+1
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     89              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); //motor driver
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x2020             MOVS     R0,#+32
   \       0x44   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     90              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); //motor driver
   \       0x48   0x2101             MOVS     R1,#+1
   \       0x4A   0x2010             MOVS     R0,#+16
   \       0x4C   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     91          
     92          }
   \       0x50   0xBD01             POP      {R0,PC}
     93          

   \                                 In section .text, align 2, keep-with-next
     94          void EnableHCSR04PeriphClock() {
   \                     EnableHCSR04PeriphClock: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     95                //초음파 센서용 타이머
     96          
     97             RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x2004             MOVS     R0,#+4
   \        0x6   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     98             RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x2008             MOVS     R0,#+8
   \        0xE   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     99              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,  ENABLE);
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    100          }
   \       0x1A   0xBD01             POP      {R0,PC}
    101          

   \                                 In section .text, align 2, keep-with-next
    102          void GPIO_Configure() {
   \                     GPIO_Configure: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    103              //motor driver PD (8, 9)왼쪽 앞, (10,11)오른쪽 앞,
    104              // (12,13)왼쪽 뒤, (14,15)오른쪽 뒤
    105              //PC8 +
    106              GPIO_InitTypeDef GPIO_InitStructure;
    107              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
   \        0x2   0xF44F 0x7080      MOV      R0,#+256
   \        0x6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    108              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \        0xA   0x2003             MOVS     R0,#+3
   \        0xC   0xF88D 0x0002      STRB     R0,[SP, #+2]
    109              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0x10   0x2010             MOVS     R0,#+16
   \       0x12   0xF88D 0x0003      STRB     R0,[SP, #+3]
    110              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \       0x16   0x4669             MOV      R1,SP
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x1C   0x.... 0x....      BL       GPIO_Init
    111          
    112              //PC9 -
    113              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \       0x20   0xF44F 0x7000      MOV      R0,#+512
   \       0x24   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    114              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x28   0x2003             MOVS     R0,#+3
   \       0x2A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    115              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0x2E   0x2010             MOVS     R0,#+16
   \       0x30   0xF88D 0x0003      STRB     R0,[SP, #+3]
    116              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \       0x34   0x4669             MOV      R1,SP
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x3A   0x.... 0x....      BL       GPIO_Init
    117              //PD10 +
    118              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
   \       0x3E   0x2020             MOVS     R0,#+32
   \       0x40   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    119              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x44   0x2003             MOVS     R0,#+3
   \       0x46   0xF88D 0x0002      STRB     R0,[SP, #+2]
    120              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0x4A   0x2010             MOVS     R0,#+16
   \       0x4C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    121              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \       0x50   0x4669             MOV      R1,SP
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x56   0x.... 0x....      BL       GPIO_Init
    122              //PD11 -
    123           
    124              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
   \       0x5A   0x2040             MOVS     R0,#+64
   \       0x5C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    125              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x60   0x2003             MOVS     R0,#+3
   \       0x62   0xF88D 0x0002      STRB     R0,[SP, #+2]
    126              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0x66   0x2010             MOVS     R0,#+16
   \       0x68   0xF88D 0x0003      STRB     R0,[SP, #+3]
    127              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \       0x6C   0x4669             MOV      R1,SP
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x72   0x.... 0x....      BL       GPIO_Init
    128              //PD12 +
    129              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
   \       0x76   0xF44F 0x5080      MOV      R0,#+4096
   \       0x7A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    130              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x7E   0x2003             MOVS     R0,#+3
   \       0x80   0xF88D 0x0002      STRB     R0,[SP, #+2]
    131              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0x84   0x2010             MOVS     R0,#+16
   \       0x86   0xF88D 0x0003      STRB     R0,[SP, #+3]
    132              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \       0x8A   0x4669             MOV      R1,SP
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x90   0x.... 0x....      BL       GPIO_Init
    133          
    134              //PD13 -
    135              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
   \       0x94   0xF44F 0x5000      MOV      R0,#+8192
   \       0x98   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    136              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x9C   0x2003             MOVS     R0,#+3
   \       0x9E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    137              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0xA2   0x2010             MOVS     R0,#+16
   \       0xA4   0xF88D 0x0003      STRB     R0,[SP, #+3]
    138              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \       0xA8   0x4669             MOV      R1,SP
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0xAE   0x.... 0x....      BL       GPIO_Init
    139          
    140              //PD14 +
    141              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
   \       0xB2   0xF44F 0x4080      MOV      R0,#+16384
   \       0xB6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    142              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0xBA   0x2003             MOVS     R0,#+3
   \       0xBC   0xF88D 0x0002      STRB     R0,[SP, #+2]
    143              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0xC0   0x2010             MOVS     R0,#+16
   \       0xC2   0xF88D 0x0003      STRB     R0,[SP, #+3]
    144              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \       0xC6   0x4669             MOV      R1,SP
   \       0xC8   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0xCC   0x.... 0x....      BL       GPIO_Init
    145          
    146              //PD15 -
    147              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
   \       0xD0   0xF44F 0x4000      MOV      R0,#+32768
   \       0xD4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    148              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0xD8   0x2003             MOVS     R0,#+3
   \       0xDA   0xF88D 0x0002      STRB     R0,[SP, #+2]
    149              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0xDE   0x2010             MOVS     R0,#+16
   \       0xE0   0xF88D 0x0003      STRB     R0,[SP, #+3]
    150              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \       0xE4   0x4669             MOV      R1,SP
   \       0xE6   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0xEA   0x.... 0x....      BL       GPIO_Init
    151          
    152                   /* UART1 pin setting */
    153              //TX
    154              //TX는 PA9 output Push-pull
    155              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \       0xEE   0xF44F 0x7000      MOV      R0,#+512
   \       0xF2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    156              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0xF6   0x2003             MOVS     R0,#+3
   \       0xF8   0xF88D 0x0002      STRB     R0,[SP, #+2]
    157              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \       0xFC   0x2018             MOVS     R0,#+24
   \       0xFE   0xF88D 0x0003      STRB     R0,[SP, #+3]
    158              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \      0x102   0x4669             MOV      R1,SP
   \      0x104   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \      0x108   0x.... 0x....      BL       GPIO_Init
    159          
    160              //RX는 PA10 input
    161              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \      0x10C   0xF44F 0x6080      MOV      R0,#+1024
   \      0x110   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    162              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \      0x114   0x2003             MOVS     R0,#+3
   \      0x116   0xF88D 0x0002      STRB     R0,[SP, #+2]
    163              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \      0x11A   0x2028             MOVS     R0,#+40
   \      0x11C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    164              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \      0x120   0x4669             MOV      R1,SP
   \      0x122   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \      0x126   0x.... 0x....      BL       GPIO_Init
    165          
    166          
    167          
    168              /* UART2 pin setting */
    169              //TX
    170              //TX는 PA2 output Push-pull
    171              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
   \      0x12A   0x2004             MOVS     R0,#+4
   \      0x12C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    172              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \      0x130   0x2003             MOVS     R0,#+3
   \      0x132   0xF88D 0x0002      STRB     R0,[SP, #+2]
    173              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \      0x136   0x2018             MOVS     R0,#+24
   \      0x138   0xF88D 0x0003      STRB     R0,[SP, #+3]
    174              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \      0x13C   0x4669             MOV      R1,SP
   \      0x13E   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \      0x142   0x.... 0x....      BL       GPIO_Init
    175          
    176              //RX는 PA3 input
    177              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
   \      0x146   0x2008             MOVS     R0,#+8
   \      0x148   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    178              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \      0x14C   0x2003             MOVS     R0,#+3
   \      0x14E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    179              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \      0x152   0x2028             MOVS     R0,#+40
   \      0x154   0xF88D 0x0003      STRB     R0,[SP, #+3]
    180              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \      0x158   0x4669             MOV      R1,SP
   \      0x15A   0x.... 0x....      LDR.W    R0,??DataTable22_1
   \      0x15E   0x.... 0x....      BL       GPIO_Init
    181          
    182              //적외선 센서 PC0
    183              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
   \      0x162   0x2001             MOVS     R0,#+1
   \      0x164   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    184              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \      0x168   0x2048             MOVS     R0,#+72
   \      0x16A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    185              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \      0x16E   0x2003             MOVS     R0,#+3
   \      0x170   0xF88D 0x0002      STRB     R0,[SP, #+2]
    186              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \      0x174   0x4669             MOV      R1,SP
   \      0x176   0x.... 0x....      LDR.W    R0,??DataTable22
   \      0x17A   0x.... 0x....      BL       GPIO_Init
    187          
    188              //적외선 센서 PC2
    189              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
   \      0x17E   0x2004             MOVS     R0,#+4
   \      0x180   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    190              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \      0x184   0x2048             MOVS     R0,#+72
   \      0x186   0xF88D 0x0003      STRB     R0,[SP, #+3]
    191              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \      0x18A   0x2003             MOVS     R0,#+3
   \      0x18C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    192              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \      0x190   0x4669             MOV      R1,SP
   \      0x192   0x.... 0x....      LDR.W    R0,??DataTable22
   \      0x196   0x.... 0x....      BL       GPIO_Init
    193          }
   \      0x19A   0xBD01             POP      {R0,PC}
    194          
    195          //적외선 인식용 EXTI

   \                                 In section .text, align 2, keep-with-next
    196          void EXTI_config(void)
    197          {
   \                     EXTI_config: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    198              EXTI_InitTypeDef EXTI_InitStructure;
    199              
    200              //왼쪽 IR센서
    201              GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource0);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x.... 0x....      BL       GPIO_EXTILineConfig
    202              EXTI_InitStructure.EXTI_Line = EXTI_Line0;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x9000             STR      R0,[SP, #+0]
    203              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xF88D 0x0004      STRB     R0,[SP, #+4]
    204              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \       0x14   0x200C             MOVS     R0,#+12
   \       0x16   0xF88D 0x0005      STRB     R0,[SP, #+5]
    205              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xF88D 0x0006      STRB     R0,[SP, #+6]
    206              EXTI_Init(&EXTI_InitStructure);
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0x.... 0x....      BL       EXTI_Init
    207          
    208              //오른쪽 IR센서
    209              GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource2);
   \       0x26   0x2102             MOVS     R1,#+2
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0x.... 0x....      BL       GPIO_EXTILineConfig
    210              EXTI_InitStructure.EXTI_Line = EXTI_Line2;
   \       0x2E   0x2004             MOVS     R0,#+4
   \       0x30   0x9000             STR      R0,[SP, #+0]
    211              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF88D 0x0004      STRB     R0,[SP, #+4]
    212              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \       0x38   0x200C             MOVS     R0,#+12
   \       0x3A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    213              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0xF88D 0x0006      STRB     R0,[SP, #+6]
    214              EXTI_Init(&EXTI_InitStructure);
   \       0x44   0x4668             MOV      R0,SP
   \       0x46   0x.... 0x....      BL       EXTI_Init
    215          }
   \       0x4A   0xBD07             POP      {R0-R2,PC}
    216          
    217          

   \                                 In section .text, align 2, keep-with-next
    218          void USART1_Init(void)
    219          {
   \                     USART1_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    220             USART_InitTypeDef USART1_InitStructure;
    221              //stm32f10x_usart.h참고
    222             // Enable the USART1 peripheral
    223             USART_Cmd(USART1, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \        0x8   0x.... 0x....      BL       USART_Cmd
    224          
    225             //저번 실험에서 설정한 값으로 구현한다.
    226             // TODO: Initialize the USART using the structure 'USART_InitTypeDef' and the function 'USART_Init'
    227                  USART1_InitStructure.USART_BaudRate = 9600;
   \        0xC   0xF44F 0x5016      MOV      R0,#+9600
   \       0x10   0x9000             STR      R0,[SP, #+0]
    228                  USART1_InitStructure.USART_WordLength = USART_WordLength_8b;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    229                  USART1_InitStructure.USART_StopBits = USART_StopBits_1;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    230                  USART1_InitStructure.USART_Parity = USART_Parity_No;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    231                  USART1_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \       0x24   0x200C             MOVS     R0,#+12
   \       0x26   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    232                  USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    233                  USART_Init(USART1, &USART1_InitStructure);
   \       0x30   0x4669             MOV      R1,SP
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \       0x36   0x.... 0x....      BL       USART_Init
    234          
    235             // TODO: Enable the USART1 RX interrupts using the function 'USART_ITConfig' and the argument value 'Receive Data register not empty interrupt'
    236                  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); //RXNE = 'Receive Data register not empty interrupt'
   \       0x3A   0x2201             MOVS     R2,#+1
   \       0x3C   0xF240 0x5125      MOVW     R1,#+1317
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \       0x44   0x.... 0x....      BL       USART_ITConfig
    237          }
   \       0x48   0xB005             ADD      SP,SP,#+20
   \       0x4A   0xBD00             POP      {PC}
    238          
    239          
    240          //블루투스 통신용 USART2

   \                                 In section .text, align 2, keep-with-next
    241          void USART2_Init(void)
    242          {
   \                     USART2_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    243              USART_InitTypeDef USART2_InitStructure;
    244              //stm32f10x_usart.h참고
    245              // Enable the USART1 peripheral
    246              USART_Cmd(USART2, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \        0x8   0x.... 0x....      BL       USART_Cmd
    247          
    248              //저번 실험에서 설정한 값으로 구현한다.
    249              // TODO: Initialize the USART using the structure 'USART_InitTypeDef' and the function 'USART_Init'
    250              USART2_InitStructure.USART_BaudRate = 9600;
   \        0xC   0xF44F 0x5016      MOV      R0,#+9600
   \       0x10   0x9000             STR      R0,[SP, #+0]
    251              USART2_InitStructure.USART_WordLength = USART_WordLength_8b;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    252              USART2_InitStructure.USART_StopBits = USART_StopBits_1;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    253              USART2_InitStructure.USART_Parity = USART_Parity_No;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    254              USART2_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \       0x24   0x200C             MOVS     R0,#+12
   \       0x26   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    255              USART2_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    256              USART_Init(USART2, &USART2_InitStructure);
   \       0x30   0x4669             MOV      R1,SP
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \       0x36   0x.... 0x....      BL       USART_Init
    257          
    258              // TODO: Enable the USART1 RX interrupts using the function 'USART_ITConfig' and the argument value 'Receive Data register not empty interrupt'
    259              USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); //RXNE = 'Receive Data register not empty interrupt'
   \       0x3A   0x2201             MOVS     R2,#+1
   \       0x3C   0xF240 0x5125      MOVW     R1,#+1317
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \       0x44   0x.... 0x....      BL       USART_ITConfig
    260          }
   \       0x48   0xB005             ADD      SP,SP,#+20
   \       0x4A   0xBD00             POP      {PC}
    261          
    262          //USART2 interrupt = 블루투스

   \                                 In section .text, align 2, keep-with-next
    263          void NVIC_Configure(void) {
   \                     NVIC_Configure: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    264              NVIC_InitTypeDef NVIC_InitStructure;
    265          
    266              //BT 인터럽트
    267              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \        0x2   0xF44F 0x60A0      MOV      R0,#+1280
   \        0x6   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    268              // UART2
    269              // 'NVIC_EnableIRQ' is only required for USART setting
    270          
    271          
    272              // UART1
    273             // 'NVIC_EnableIRQ' is only required for USART setting
    274              NVIC_EnableIRQ(USART1_IRQn);
   \        0xA   0x2025             MOVS     R0,#+37
   \        0xC   0x.... 0x....      BL       __NVIC_EnableIRQ
    275              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \       0x10   0x2025             MOVS     R0,#+37
   \       0x12   0xF88D 0x0000      STRB     R0,[SP, #+0]
    276              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // TODO
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xF88D 0x0001      STRB     R0,[SP, #+1]
    277              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // TODO
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    278              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xF88D 0x0003      STRB     R0,[SP, #+3]
    279              NVIC_Init(&NVIC_InitStructure);
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x.... 0x....      BL       NVIC_Init
    280          
    281          
    282              // UART2
    283             // 'NVIC_EnableIRQ' is only required for USART setting
    284              NVIC_EnableIRQ(USART2_IRQn);
   \       0x2E   0x2026             MOVS     R0,#+38
   \       0x30   0x.... 0x....      BL       __NVIC_EnableIRQ
    285              NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
   \       0x34   0x2026             MOVS     R0,#+38
   \       0x36   0xF88D 0x0000      STRB     R0,[SP, #+0]
    286              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // TODO
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    287              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // TODO
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xF88D 0x0002      STRB     R0,[SP, #+2]
    288              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xF88D 0x0003      STRB     R0,[SP, #+3]
    289              NVIC_Init(&NVIC_InitStructure);
   \       0x4C   0x4668             MOV      R0,SP
   \       0x4E   0x.... 0x....      BL       NVIC_Init
    290          
    291          
    292              //SR 센서 인터럽트
    293              NVIC_EnableIRQ(TIM3_IRQn);
   \       0x52   0x201D             MOVS     R0,#+29
   \       0x54   0x.... 0x....      BL       __NVIC_EnableIRQ
    294              NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
   \       0x58   0x201D             MOVS     R0,#+29
   \       0x5A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    295              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // TODO
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xF88D 0x0001      STRB     R0,[SP, #+1]
    296              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // TODO
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF88D 0x0002      STRB     R0,[SP, #+2]
    297              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x6A   0x2001             MOVS     R0,#+1
   \       0x6C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    298              NVIC_Init(&NVIC_InitStructure);
   \       0x70   0x4668             MOV      R0,SP
   \       0x72   0x.... 0x....      BL       NVIC_Init
    299          
    300              //IR 센서 인터럽트 C0 (왼쪽)
    301              NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
   \       0x76   0x2006             MOVS     R0,#+6
   \       0x78   0xF88D 0x0000      STRB     R0,[SP, #+0]
    302              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // TODO
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    303              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; // TODO
   \       0x82   0x2002             MOVS     R0,#+2
   \       0x84   0xF88D 0x0002      STRB     R0,[SP, #+2]
    304              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x88   0x2001             MOVS     R0,#+1
   \       0x8A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    305              NVIC_Init(&NVIC_InitStructure);
   \       0x8E   0x4668             MOV      R0,SP
   \       0x90   0x.... 0x....      BL       NVIC_Init
    306          
    307              //IR 센서 인터럽트 C2 (오른쪽)
    308              NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;
   \       0x94   0x2008             MOVS     R0,#+8
   \       0x96   0xF88D 0x0000      STRB     R0,[SP, #+0]
    309              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // TODO
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    310              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; // TODO
   \       0xA0   0x2002             MOVS     R0,#+2
   \       0xA2   0xF88D 0x0002      STRB     R0,[SP, #+2]
    311              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xF88D 0x0003      STRB     R0,[SP, #+3]
    312              NVIC_Init(&NVIC_InitStructure);
   \       0xAC   0x4668             MOV      R0,SP
   \       0xAE   0x.... 0x....      BL       NVIC_Init
    313          }
   \       0xB2   0xBD01             POP      {R0,PC}
    314          
    315          //적외선 좌측 interrupt

   \                                 In section .text, align 2, keep-with-next
    316          void EXTI0_IRQHandler(void)
    317          {
   \                     EXTI0_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    318              if (EXTI_GetITStatus(EXTI_Line0) != RESET){
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x.... 0x....      BL       EXTI_GetITStatus
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD037             BEQ.N    ??EXTI0_IRQHandler_0
    319                  if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0) == Bit_RESET){
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x12   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD12D             BNE.N    ??EXTI0_IRQHandler_1
    320                      GPIO_ResetBits(GPIOC, GPIO_Pin_8);
   \       0x1A   0xF44F 0x7180      MOV      R1,#+256
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x22   0x.... 0x....      BL       GPIO_ResetBits
    321                    GPIO_ResetBits(GPIOC, GPIO_Pin_9);
   \       0x26   0xF44F 0x7100      MOV      R1,#+512
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x2E   0x.... 0x....      BL       GPIO_ResetBits
    322          
    323                    GPIO_ResetBits(GPIOD, GPIO_Pin_5);
   \       0x32   0x2120             MOVS     R1,#+32
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x38   0x.... 0x....      BL       GPIO_ResetBits
    324                    GPIO_ResetBits(GPIOD, GPIO_Pin_6);
   \       0x3C   0x2140             MOVS     R1,#+64
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x42   0x.... 0x....      BL       GPIO_ResetBits
    325          
    326                    GPIO_ResetBits(GPIOD, GPIO_Pin_12);
   \       0x46   0xF44F 0x5180      MOV      R1,#+4096
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x4E   0x.... 0x....      BL       GPIO_ResetBits
    327                    GPIO_ResetBits(GPIOD, GPIO_Pin_13);
   \       0x52   0xF44F 0x5100      MOV      R1,#+8192
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x5A   0x.... 0x....      BL       GPIO_ResetBits
    328          
    329                    GPIO_ResetBits(GPIOD, GPIO_Pin_14);
   \       0x5E   0xF44F 0x4180      MOV      R1,#+16384
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x66   0x.... 0x....      BL       GPIO_ResetBits
    330                    GPIO_ResetBits(GPIOD, GPIO_Pin_15);
   \       0x6A   0xF44F 0x4100      MOV      R1,#+32768
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x72   0x.... 0x....      BL       GPIO_ResetBits
    331                  }
    332                  EXTI_ClearITPendingBit(EXTI_Line0);
   \                     ??EXTI0_IRQHandler_1: (+1)
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0x.... 0x....      BL       EXTI_ClearITPendingBit
    333              }
    334          }
   \                     ??EXTI0_IRQHandler_0: (+1)
   \       0x7C   0xBD01             POP      {R0,PC}
    335          
    336          
    337          //적외선 우측 interrupt

   \                                 In section .text, align 2, keep-with-next
    338          void EXTI2_IRQHandler(void)
    339          {
   \                     EXTI2_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    340              if (EXTI_GetITStatus(EXTI_Line2) != RESET){
   \        0x2   0x2004             MOVS     R0,#+4
   \        0x4   0x.... 0x....      BL       EXTI_GetITStatus
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD037             BEQ.N    ??EXTI2_IRQHandler_0
    341                  if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2) == Bit_RESET){
   \        0xC   0x2104             MOVS     R1,#+4
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x12   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD12D             BNE.N    ??EXTI2_IRQHandler_1
    342                      GPIO_ResetBits(GPIOC, GPIO_Pin_8);
   \       0x1A   0xF44F 0x7180      MOV      R1,#+256
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x22   0x.... 0x....      BL       GPIO_ResetBits
    343                    GPIO_ResetBits(GPIOC, GPIO_Pin_9);
   \       0x26   0xF44F 0x7100      MOV      R1,#+512
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x2E   0x.... 0x....      BL       GPIO_ResetBits
    344          
    345                    GPIO_ResetBits(GPIOD, GPIO_Pin_5);
   \       0x32   0x2120             MOVS     R1,#+32
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x38   0x.... 0x....      BL       GPIO_ResetBits
    346                    GPIO_ResetBits(GPIOD, GPIO_Pin_6);
   \       0x3C   0x2140             MOVS     R1,#+64
   \       0x3E   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x42   0x.... 0x....      BL       GPIO_ResetBits
    347          
    348                    GPIO_ResetBits(GPIOD, GPIO_Pin_12);
   \       0x46   0xF44F 0x5180      MOV      R1,#+4096
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x4E   0x.... 0x....      BL       GPIO_ResetBits
    349                    GPIO_ResetBits(GPIOD, GPIO_Pin_13);
   \       0x52   0xF44F 0x5100      MOV      R1,#+8192
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x5A   0x.... 0x....      BL       GPIO_ResetBits
    350          
    351                    GPIO_ResetBits(GPIOD, GPIO_Pin_14);
   \       0x5E   0xF44F 0x4180      MOV      R1,#+16384
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x66   0x.... 0x....      BL       GPIO_ResetBits
    352                    GPIO_ResetBits(GPIOD, GPIO_Pin_15);
   \       0x6A   0xF44F 0x4100      MOV      R1,#+32768
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x72   0x.... 0x....      BL       GPIO_ResetBits
    353                  }
    354                  EXTI_ClearITPendingBit(EXTI_Line2);
   \                     ??EXTI2_IRQHandler_1: (+1)
   \       0x76   0x2004             MOVS     R0,#+4
   \       0x78   0x.... 0x....      BL       EXTI_ClearITPendingBit
    355              }
    356          }
   \                     ??EXTI2_IRQHandler_0: (+1)
   \       0x7C   0xBD01             POP      {R0,PC}
    357          
    358          //초음파 센서 interrupt

   \                                 In section .text, align 2, keep-with-next
    359          void TIM3_IRQHandler(){
   \                     TIM3_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    360              if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET){
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable22_4
   \        0x8   0x.... 0x....      BL       TIM_GetITStatus
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD03D             BEQ.N    ??TIM3_IRQHandler_0
    361                  dist = HCSR04GetDistance();
   \       0x10   0x.... 0x....      BL       HCSR04GetDistance
   \       0x14   0x.... 0x....      LDR.W    R1,??DataTable22_5
   \       0x18   0x6008             STR      R0,[R1, #+0]
   \       0x1A   0xE032             B.N      ??TIM3_IRQHandler_1
    362                  while(dist < 80) {
    363                      GPIO_ResetBits(GPIOC, GPIO_Pin_8);
   \                     ??TIM3_IRQHandler_2: (+1)
   \       0x1C   0xF44F 0x7180      MOV      R1,#+256
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x24   0x.... 0x....      BL       GPIO_ResetBits
    364                    GPIO_ResetBits(GPIOC, GPIO_Pin_9);
   \       0x28   0xF44F 0x7100      MOV      R1,#+512
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x30   0x.... 0x....      BL       GPIO_ResetBits
    365          
    366                    GPIO_ResetBits(GPIOD, GPIO_Pin_5);
   \       0x34   0x2120             MOVS     R1,#+32
   \       0x36   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x3A   0x.... 0x....      BL       GPIO_ResetBits
    367                    GPIO_ResetBits(GPIOD, GPIO_Pin_6);
   \       0x3E   0x2140             MOVS     R1,#+64
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x44   0x.... 0x....      BL       GPIO_ResetBits
    368          
    369                    GPIO_ResetBits(GPIOD, GPIO_Pin_12);
   \       0x48   0xF44F 0x5180      MOV      R1,#+4096
   \       0x4C   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x50   0x.... 0x....      BL       GPIO_ResetBits
    370                    GPIO_ResetBits(GPIOD, GPIO_Pin_13);
   \       0x54   0xF44F 0x5100      MOV      R1,#+8192
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x5C   0x.... 0x....      BL       GPIO_ResetBits
    371          
    372                    GPIO_ResetBits(GPIOD, GPIO_Pin_14);
   \       0x60   0xF44F 0x4180      MOV      R1,#+16384
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x68   0x.... 0x....      BL       GPIO_ResetBits
    373                    GPIO_ResetBits(GPIOD, GPIO_Pin_15);
   \       0x6C   0xF44F 0x4100      MOV      R1,#+32768
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x74   0x.... 0x....      BL       GPIO_ResetBits
    374          
    375                      dist = HCSR04GetDistance();
   \       0x78   0x.... 0x....      BL       HCSR04GetDistance
   \       0x7C   0x.... 0x....      LDR.W    R1,??DataTable22_5
   \       0x80   0x6008             STR      R0,[R1, #+0]
    376                  }
   \                     ??TIM3_IRQHandler_1: (+1)
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable22_5
   \       0x86   0x6800             LDR      R0,[R0, #+0]
   \       0x88   0x2850             CMP      R0,#+80
   \       0x8A   0xD3C7             BCC.N    ??TIM3_IRQHandler_2
    377              }
    378              TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
   \                     ??TIM3_IRQHandler_0: (+1)
   \       0x8C   0x2101             MOVS     R1,#+1
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable22_4
   \       0x92   0x.... 0x....      BL       TIM_ClearITPendingBit
    379          }
   \       0x96   0xBD01             POP      {R0,PC}
    380          
    381          
    382          

   \                                 In section .text, align 2, keep-with-next
    383          void sendDataUART1(uint16_t data) {
   \                     sendDataUART1: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x0001             MOVS     R1,R0
    384             /* Wait till TC is set */
    385             USART_SendData(USART1, data);
   \        0x4   0xB289             UXTH     R1,R1
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \        0xA   0x.... 0x....      BL       USART_SendData
    386          }
   \        0xE   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
    387          void sendDataUART2(uint16_t data) {
   \                     sendDataUART2: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x0001             MOVS     R1,R0
    388             /* Wait till TC is set */
    389             USART_SendData(USART2, data);
   \        0x4   0xB289             UXTH     R1,R1
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \        0xA   0x.... 0x....      BL       USART_SendData
    390          }
   \        0xE   0xBD01             POP      {R0,PC}
    391          
    392          

   \                                 In section .text, align 2, keep-with-next
    393          void USART1_IRQHandler() {
   \                     USART1_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    394             uint16_t word;
    395              if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){
   \        0x2   0xF240 0x5125      MOVW     R1,#+1317
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \        0xA   0x.... 0x....      BL       USART_GetITStatus
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD00C             BEQ.N    ??USART1_IRQHandler_0
    396                 // the most recent received data by the USART1 peripheral
    397                  word = USART_ReceiveData(USART1);
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \       0x16   0x.... 0x....      BL       USART_ReceiveData
    398                  sendDataUART2(word);
   \       0x1A   0xB280             UXTH     R0,R0
   \       0x1C   0x.... 0x....      BL       sendDataUART2
    399                  // clear 'Read data register not empty' flag
    400                 USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \       0x20   0xF240 0x5125      MOVW     R1,#+1317
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable22_2
   \       0x28   0x.... 0x....      BL       USART_ClearITPendingBit
    401              }
    402          }
   \                     ??USART1_IRQHandler_0: (+1)
   \       0x2C   0xBD01             POP      {R0,PC}
    403          
    404          
    405          //블루투스 interrupt

   \                                 In section .text, align 2, keep-with-next
    406          void USART2_IRQHandler(void) {
   \                     USART2_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    407              uint16_t word;
    408              if(USART_GetITStatus(USART2,USART_IT_RXNE)!=RESET){
   \        0x2   0xF240 0x5125      MOVW     R1,#+1317
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \        0xA   0x.... 0x....      BL       USART_GetITStatus
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD012             BEQ.N    ??USART2_IRQHandler_0
    409                  // the most recent received data by the USART1 peripheral
    410                  word = USART_ReceiveData(USART2);
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \       0x16   0x.... 0x....      BL       USART_ReceiveData
   \       0x1A   0x0004             MOVS     R4,R0
    411                  sendDataUART1(word);
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x.... 0x....      BL       sendDataUART1
    412           
    413                  //수신 받은 명령어를 적용
    414                  setCMD(word);
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0x.... 0x....      BL       setCMD
    415          
    416                  // clear 'Read data register not empty' flag
    417                  USART_ClearITPendingBit(USART2,USART_IT_RXNE);
   \       0x2C   0xF240 0x5125      MOVW     R1,#+1317
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable22_3
   \       0x34   0x.... 0x....      BL       USART_ClearITPendingBit
    418              }
    419          
    420          }
   \                     ??USART2_IRQHandler_0: (+1)
   \       0x38   0xBD10             POP      {R4,PC}
    421            
    422          //블루투스 초기화 작업

   \                                 In section .text, align 2, keep-with-next
    423          void startBT()
    424          {
   \                     startBT: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
    425             char startup[] = "BTWIN Slave Mode Start";
   \        0x4   0xA803             ADD      R0,SP,#+12
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable22_6
   \        0xA   0x2218             MOVS     R2,#+24
   \        0xC   0x.... 0x....      BL       __aeabi_memcpy4
    426              char startScan[] = "AT+BTSCAN";
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable22_7
   \       0x16   0xE891 0x001C      LDM      R1,{R2-R4}
   \       0x1A   0xE880 0x001C      STM      R0,{R2-R4}
    427          
    428              //USART1과 USB 연결의 부재로인해 스스로 slave mod를 동작시키도록 함.
    429              //자기자신에게 slave mode 구동과 스캔 명령어를 보냄.
    430              for (int i = 0; i < 23; i ++)
   \       0x1E   0x2400             MOVS     R4,#+0
   \       0x20   0xE005             B.N      ??startBT_0
    431                  sendDataUART2(startup[i]);
   \                     ??startBT_1: (+1)
   \       0x22   0xA803             ADD      R0,SP,#+12
   \       0x24   0x5D00             LDRB     R0,[R0, R4]
   \       0x26   0xB280             UXTH     R0,R0
   \       0x28   0x.... 0x....      BL       sendDataUART2
   \       0x2C   0x1C64             ADDS     R4,R4,#+1
   \                     ??startBT_0: (+1)
   \       0x2E   0x2C17             CMP      R4,#+23
   \       0x30   0xDBF7             BLT.N    ??startBT_1
    432          
    433              for (int i = 0; i < 10; i ++)
   \       0x32   0x2400             MOVS     R4,#+0
   \       0x34   0xE005             B.N      ??startBT_2
    434                  sendDataUART2(startScan[i]);
   \                     ??startBT_3: (+1)
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x5D00             LDRB     R0,[R0, R4]
   \       0x3A   0xB280             UXTH     R0,R0
   \       0x3C   0x.... 0x....      BL       sendDataUART2
   \       0x40   0x1C64             ADDS     R4,R4,#+1
   \                     ??startBT_2: (+1)
   \       0x42   0x2C0A             CMP      R4,#+10
   \       0x44   0xDBF7             BLT.N    ??startBT_3
    435          }
   \       0x46   0xB00A             ADD      SP,SP,#+40
   \       0x48   0xBD10             POP      {R4,PC}

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x42 0x54          DC8 "BTWIN Slave Mode Start"

   \              0x57 0x49    

   \              0x4E 0x20    

   \              0x53 0x6C    

   \              0x61 0x76    

   \              0x65 0x20    

   \              0x4D 0x6F    

   \              0x64 0x65    

   \              0x20 0x53    

   \              0x74 0x61    

   \              0x72 0x74    

   \              0x00
   \       0x17                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x41 0x54          DC8 "AT+BTSCAN"

   \              0x2B 0x42    

   \              0x54 0x53    

   \              0x43 0x41    

   \              0x4E 0x00
   \        0xA                      DS8 2
    436          

   \                                 In section .text, align 2, keep-with-next
    437          void setCMD(char flag)
    438          {
   \                     setCMD: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
    439             //학습 이후 전진
    440             if (flag == START)
   \        0x4   0x0001             MOVS     R1,R0
   \        0x6   0xB2C9             UXTB     R1,R1
   \        0x8   0x2953             CMP      R1,#+83
   \        0xA   0xD11C             BNE.N    ??setCMD_0
    441             {
    442                //사용자 확인용 메시지
    443                  char msg[] = "BT car starts";
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x.... 0x....      LDR.W    R1,??DataTable22_8
   \       0x12   0x2210             MOVS     R2,#+16
   \       0x14   0x.... 0x....      BL       __aeabi_memcpy4
    444                  for (int i = 0; i < sizeof(msg); i ++)
   \       0x18   0x2400             MOVS     R4,#+0
   \       0x1A   0xE005             B.N      ??setCMD_1
    445                   sendDataUART2(msg[i]);
   \                     ??setCMD_2: (+1)
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x5D00             LDRB     R0,[R0, R4]
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0x.... 0x....      BL       sendDataUART2
   \       0x26   0x1C64             ADDS     R4,R4,#+1
   \                     ??setCMD_1: (+1)
   \       0x28   0x2C0E             CMP      R4,#+14
   \       0x2A   0xD3F7             BCC.N    ??setCMD_2
    446          
    447                 //각 상태 설정
    448                 state = UP;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \       0x32   0x7008             STRB     R0,[R1, #+0]
    449                 learningFlag = 0;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x.... 0x....      LDR.W    R1,??DataTable22_10
   \       0x3A   0x6008             STR      R0,[R1, #+0]
    450                 waybackFlag = 0;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable22_11
   \       0x42   0x6008             STR      R0,[R1, #+0]
   \       0x44   0xE05C             B.N      ??setCMD_3
    451             }
    452             //정지 명령어
    453             else if (flag == HALT)
   \                     ??setCMD_0: (+1)
   \       0x46   0x0001             MOVS     R1,R0
   \       0x48   0xB2C9             UXTB     R1,R1
   \       0x4A   0x2948             CMP      R1,#+72
   \       0x4C   0xD11C             BNE.N    ??setCMD_4
    454             {
    455                char msg[] = "BT car stops";
   \       0x4E   0x4668             MOV      R0,SP
   \       0x50   0x.... 0x....      LDR.W    R1,??DataTable22_12
   \       0x54   0x2210             MOVS     R2,#+16
   \       0x56   0x.... 0x....      BL       __aeabi_memcpy4
    456                  for (int i = 0; i < sizeof(msg); i ++)
   \       0x5A   0x2400             MOVS     R4,#+0
   \       0x5C   0xE005             B.N      ??setCMD_5
    457                      sendDataUART2(msg[i]);
   \                     ??setCMD_6: (+1)
   \       0x5E   0x4668             MOV      R0,SP
   \       0x60   0x5D00             LDRB     R0,[R0, R4]
   \       0x62   0xB280             UXTH     R0,R0
   \       0x64   0x.... 0x....      BL       sendDataUART2
   \       0x68   0x1C64             ADDS     R4,R4,#+1
   \                     ??setCMD_5: (+1)
   \       0x6A   0x2C0D             CMP      R4,#+13
   \       0x6C   0xD3F7             BCC.N    ??setCMD_6
    458                  state = STOP;
   \       0x6E   0x2004             MOVS     R0,#+4
   \       0x70   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \       0x74   0x7008             STRB     R0,[R1, #+0]
    459                  learningFlag = 0;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x.... 0x....      LDR.W    R1,??DataTable22_10
   \       0x7C   0x6008             STR      R0,[R1, #+0]
    460                  waybackFlag = 0;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x.... 0x....      LDR.W    R1,??DataTable22_11
   \       0x84   0x6008             STR      R0,[R1, #+0]
   \       0x86   0xE03B             B.N      ??setCMD_3
    461             }
    462             //학습 시작 명령어
    463             else if (flag == LEARN)
   \                     ??setCMD_4: (+1)
   \       0x88   0xB2C0             UXTB     R0,R0
   \       0x8A   0x284C             CMP      R0,#+76
   \       0x8C   0xD11C             BNE.N    ??setCMD_7
    464              {
    465                char msg[] = "BT car learning starts";
   \       0x8E   0x4668             MOV      R0,SP
   \       0x90   0x.... 0x....      LDR.W    R1,??DataTable22_13
   \       0x94   0x2218             MOVS     R2,#+24
   \       0x96   0x.... 0x....      BL       __aeabi_memcpy4
    466                  for (int i = 0; i < sizeof(msg); i ++)
   \       0x9A   0x2400             MOVS     R4,#+0
   \       0x9C   0xE005             B.N      ??setCMD_8
    467                      sendDataUART2(msg[i]);
   \                     ??setCMD_9: (+1)
   \       0x9E   0x4668             MOV      R0,SP
   \       0xA0   0x5D00             LDRB     R0,[R0, R4]
   \       0xA2   0xB280             UXTH     R0,R0
   \       0xA4   0x.... 0x....      BL       sendDataUART2
   \       0xA8   0x1C64             ADDS     R4,R4,#+1
   \                     ??setCMD_8: (+1)
   \       0xAA   0x2C17             CMP      R4,#+23
   \       0xAC   0xD3F7             BCC.N    ??setCMD_9
    468                  state = UP;
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \       0xB4   0x7008             STRB     R0,[R1, #+0]
    469                  learningFlag = 1;
   \       0xB6   0x2001             MOVS     R0,#+1
   \       0xB8   0x.... 0x....      LDR.W    R1,??DataTable22_10
   \       0xBC   0x6008             STR      R0,[R1, #+0]
    470                  waybackFlag = 0;
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0x.... 0x....      LDR.W    R1,??DataTable22_11
   \       0xC4   0x6008             STR      R0,[R1, #+0]
   \       0xC6   0xE01B             B.N      ??setCMD_3
    471          
    472             }
    473             else
    474             {
    475                char msg[] = "Not a proper command";
   \                     ??setCMD_7: (+1)
   \       0xC8   0x4668             MOV      R0,SP
   \       0xCA   0x.... 0x....      LDR.W    R1,??DataTable22_14
   \       0xCE   0x2218             MOVS     R2,#+24
   \       0xD0   0x.... 0x....      BL       __aeabi_memcpy4
    476                  for (int i = 0; i < sizeof(msg); i ++)
   \       0xD4   0x2400             MOVS     R4,#+0
   \       0xD6   0xE005             B.N      ??setCMD_10
    477                      sendDataUART2(msg[i]);
   \                     ??setCMD_11: (+1)
   \       0xD8   0x4668             MOV      R0,SP
   \       0xDA   0x5D00             LDRB     R0,[R0, R4]
   \       0xDC   0xB280             UXTH     R0,R0
   \       0xDE   0x.... 0x....      BL       sendDataUART2
   \       0xE2   0x1C64             ADDS     R4,R4,#+1
   \                     ??setCMD_10: (+1)
   \       0xE4   0x2C15             CMP      R4,#+21
   \       0xE6   0xD3F7             BCC.N    ??setCMD_11
    478                  state = STOP;
   \       0xE8   0x2004             MOVS     R0,#+4
   \       0xEA   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \       0xEE   0x7008             STRB     R0,[R1, #+0]
    479                  learningFlag = 0;
   \       0xF0   0x2000             MOVS     R0,#+0
   \       0xF2   0x.... 0x....      LDR.W    R1,??DataTable22_10
   \       0xF6   0x6008             STR      R0,[R1, #+0]
    480                  waybackFlag = 0;
   \       0xF8   0x2000             MOVS     R0,#+0
   \       0xFA   0x.... 0x....      LDR.W    R1,??DataTable22_11
   \       0xFE   0x6008             STR      R0,[R1, #+0]
    481              }
    482          
    483              for (int i = 0; i < 10; i ++)
   \                     ??setCMD_3: (+1)
   \      0x100   0x2400             MOVS     R4,#+0
   \      0x102   0xE006             B.N      ??setCMD_12
    484                  sendDataUART2(startScan[i]);
   \                     ??setCMD_13: (+1)
   \      0x104   0x.... 0x....      LDR.W    R0,??DataTable22_15
   \      0x108   0x5D00             LDRB     R0,[R0, R4]
   \      0x10A   0xB280             UXTH     R0,R0
   \      0x10C   0x.... 0x....      BL       sendDataUART2
   \      0x110   0x1C64             ADDS     R4,R4,#+1
   \                     ??setCMD_12: (+1)
   \      0x112   0x2C0A             CMP      R4,#+10
   \      0x114   0xDBF6             BLT.N    ??setCMD_13
    485          }
   \      0x116   0xB006             ADD      SP,SP,#+24
   \      0x118   0xBD10             POP      {R4,PC}

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x42 0x54          DC8 "BT car starts"

   \              0x20 0x63    

   \              0x61 0x72    

   \              0x20 0x73    

   \              0x74 0x61    

   \              0x72 0x74    

   \              0x73 0x00
   \        0xE                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x42 0x54          DC8 "BT car stops"

   \              0x20 0x63    

   \              0x61 0x72    

   \              0x20 0x73    

   \              0x74 0x6F    

   \              0x70 0x73    

   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x42 0x54          DC8 "BT car learning starts"

   \              0x20 0x63    

   \              0x61 0x72    

   \              0x20 0x6C    

   \              0x65 0x61    

   \              0x72 0x6E    

   \              0x69 0x6E    

   \              0x67 0x20    

   \              0x73 0x74    

   \              0x61 0x72    

   \              0x74 0x73    

   \              0x00
   \       0x17                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x4E 0x6F          DC8 "Not a proper command"

   \              0x74 0x20    

   \              0x61 0x20    

   \              0x70 0x72    

   \              0x6F 0x70    

   \              0x65 0x72    

   \              0x20 0x63    

   \              0x6F 0x6D    

   \              0x6D 0x61    

   \              0x6E 0x64    

   \              0x00
   \       0x15                      DS8 3
    486          

   \                                 In section .text, align 2, keep-with-next
    487          void leftmotor(int set) {
   \                     leftmotor: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    488              //앞
    489              GPIO_ResetBits(GPIOC, GPIO_Pin_8);
   \        0x4   0xF44F 0x7180      MOV      R1,#+256
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable22
   \        0xC   0x.... 0x....      BL       GPIO_ResetBits
    490              GPIO_ResetBits(GPIOC, GPIO_Pin_9);
   \       0x10   0xF44F 0x7100      MOV      R1,#+512
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x18   0x.... 0x....      BL       GPIO_ResetBits
    491          
    492              //뒤
    493              GPIO_ResetBits(GPIOD, GPIO_Pin_12);
   \       0x1C   0xF44F 0x5180      MOV      R1,#+4096
   \       0x20   0x....             LDR.N    R0,??DataTable21_1
   \       0x22   0x.... 0x....      BL       GPIO_ResetBits
    494              GPIO_ResetBits(GPIOD, GPIO_Pin_13);
   \       0x26   0xF44F 0x5100      MOV      R1,#+8192
   \       0x2A   0x....             LDR.N    R0,??DataTable21_1
   \       0x2C   0x.... 0x....      BL       GPIO_ResetBits
    495          
    496              if(set == 1) {
   \       0x30   0x2C01             CMP      R4,#+1
   \       0x32   0xD10B             BNE.N    ??leftmotor_0
    497                  GPIO_SetBits(GPIOD, GPIO_Pin_13); //뒤
   \       0x34   0xF44F 0x5100      MOV      R1,#+8192
   \       0x38   0x....             LDR.N    R0,??DataTable21_1
   \       0x3A   0x.... 0x....      BL       GPIO_SetBits
    498                  GPIO_SetBits(GPIOC, GPIO_Pin_9); //앞
   \       0x3E   0xF44F 0x7100      MOV      R1,#+512
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x46   0x.... 0x....      BL       GPIO_SetBits
   \       0x4A   0xE00C             B.N      ??leftmotor_1
    499              }
    500              else if(set == 0) {
   \                     ??leftmotor_0: (+1)
   \       0x4C   0x2C00             CMP      R4,#+0
   \       0x4E   0xD10A             BNE.N    ??leftmotor_1
    501                  GPIO_SetBits(GPIOC, GPIO_Pin_8);
   \       0x50   0xF44F 0x7180      MOV      R1,#+256
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x58   0x.... 0x....      BL       GPIO_SetBits
    502                  GPIO_SetBits(GPIOD, GPIO_Pin_12);
   \       0x5C   0xF44F 0x5180      MOV      R1,#+4096
   \       0x60   0x....             LDR.N    R0,??DataTable21_1
   \       0x62   0x.... 0x....      BL       GPIO_SetBits
    503              }
    504          }
   \                     ??leftmotor_1: (+1)
   \       0x66   0xBD10             POP      {R4,PC}
    505          

   \                                 In section .text, align 2, keep-with-next
    506          void rightmotor(int set) {
   \                     rightmotor: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    507              //앞바퀴
    508              GPIO_ResetBits(GPIOD, GPIO_Pin_5);
   \        0x4   0x2120             MOVS     R1,#+32
   \        0x6   0x....             LDR.N    R0,??DataTable21_1
   \        0x8   0x.... 0x....      BL       GPIO_ResetBits
    509              GPIO_ResetBits(GPIOD, GPIO_Pin_6);
   \        0xC   0x2140             MOVS     R1,#+64
   \        0xE   0x....             LDR.N    R0,??DataTable21_1
   \       0x10   0x.... 0x....      BL       GPIO_ResetBits
    510              
    511              //뒷바퀴
    512              GPIO_ResetBits(GPIOD, GPIO_Pin_14);
   \       0x14   0xF44F 0x4180      MOV      R1,#+16384
   \       0x18   0x....             LDR.N    R0,??DataTable21_1
   \       0x1A   0x.... 0x....      BL       GPIO_ResetBits
    513              GPIO_ResetBits(GPIOD, GPIO_Pin_15);
   \       0x1E   0xF44F 0x4100      MOV      R1,#+32768
   \       0x22   0x....             LDR.N    R0,??DataTable21_1
   \       0x24   0x.... 0x....      BL       GPIO_ResetBits
    514          
    515              if(set == 1) {
   \       0x28   0x2C01             CMP      R4,#+1
   \       0x2A   0xD103             BNE.N    ??rightmotor_0
    516                  //GPIO_SetBits(GPIOD, GPIO_Pin_15);
    517                  GPIO_SetBits(GPIOD, GPIO_Pin_5); 
   \       0x2C   0x2120             MOVS     R1,#+32
   \       0x2E   0x....             LDR.N    R0,??DataTable21_1
   \       0x30   0x.... 0x....      BL       GPIO_SetBits
    518              }
    519              if(set == 0) {
   \                     ??rightmotor_0: (+1)
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD103             BNE.N    ??rightmotor_1
    520                  GPIO_SetBits(GPIOD, GPIO_Pin_6); //앞
   \       0x38   0x2140             MOVS     R1,#+64
   \       0x3A   0x....             LDR.N    R0,??DataTable21_1
   \       0x3C   0x.... 0x....      BL       GPIO_SetBits
    521                  //GPIO_SetBits(GPIOD, GPIO_Pin_14); //뒤
    522              }
    523          }
   \                     ??rightmotor_1: (+1)
   \       0x40   0xBD10             POP      {R4,PC}
    524          

   \                                 In section .text, align 2, keep-with-next
    525          void motorstop() {
   \                     motorstop: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    526              GPIO_ResetBits(GPIOC, GPIO_Pin_8);
   \        0x2   0xF44F 0x7180      MOV      R1,#+256
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable22
   \        0xA   0x.... 0x....      BL       GPIO_ResetBits
    527              GPIO_ResetBits(GPIOC, GPIO_Pin_9);
   \        0xE   0xF44F 0x7100      MOV      R1,#+512
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x16   0x.... 0x....      BL       GPIO_ResetBits
    528          
    529              GPIO_ResetBits(GPIOD, GPIO_Pin_5);
   \       0x1A   0x2120             MOVS     R1,#+32
   \       0x1C   0x....             LDR.N    R0,??DataTable21_1
   \       0x1E   0x.... 0x....      BL       GPIO_ResetBits
    530              GPIO_ResetBits(GPIOD, GPIO_Pin_6);
   \       0x22   0x2140             MOVS     R1,#+64
   \       0x24   0x....             LDR.N    R0,??DataTable21_1
   \       0x26   0x.... 0x....      BL       GPIO_ResetBits
    531          
    532              GPIO_ResetBits(GPIOD, GPIO_Pin_12);
   \       0x2A   0xF44F 0x5180      MOV      R1,#+4096
   \       0x2E   0x....             LDR.N    R0,??DataTable21_1
   \       0x30   0x.... 0x....      BL       GPIO_ResetBits
    533              GPIO_ResetBits(GPIOD, GPIO_Pin_13);
   \       0x34   0xF44F 0x5100      MOV      R1,#+8192
   \       0x38   0x....             LDR.N    R0,??DataTable21_1
   \       0x3A   0x.... 0x....      BL       GPIO_ResetBits
    534          
    535              GPIO_ResetBits(GPIOD, GPIO_Pin_14);
   \       0x3E   0xF44F 0x4180      MOV      R1,#+16384
   \       0x42   0x....             LDR.N    R0,??DataTable21_1
   \       0x44   0x.... 0x....      BL       GPIO_ResetBits
    536              GPIO_ResetBits(GPIOD, GPIO_Pin_15);
   \       0x48   0xF44F 0x4100      MOV      R1,#+32768
   \       0x4C   0x....             LDR.N    R0,??DataTable21_1
   \       0x4E   0x.... 0x....      BL       GPIO_ResetBits
    537          }
   \       0x52   0xBD01             POP      {R0,PC}
    538          

   \                                 In section .text, align 2, keep-with-next
    539          void motor() {
   \                     motor: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    540              switch(state) {
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable22_9
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??motor_0
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD012             BEQ.N    ??motor_1
   \       0x10   0xD30A             BCC.N    ??motor_2
   \       0x12   0x2804             CMP      R0,#+4
   \       0x14   0xD01D             BEQ.N    ??motor_3
   \       0x16   0xD315             BCC.N    ??motor_4
   \       0x18   0xE01E             B.N      ??motor_5
    541              case UP:
    542                  leftmotor(1);
   \                     ??motor_0: (+1)
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x.... 0x....      BL       leftmotor
    543                  rightmotor(1);
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0x.... 0x....      BL       rightmotor
    544                  break;
   \       0x26   0xE019             B.N      ??motor_6
    545              case DOWN:
    546                  leftmotor(0);
   \                     ??motor_2: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x.... 0x....      BL       leftmotor
    547                  rightmotor(0);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x.... 0x....      BL       rightmotor
    548                  break;
   \       0x34   0xE012             B.N      ??motor_6
    549              case LEFT:
    550                  leftmotor(3);
   \                     ??motor_1: (+1)
   \       0x36   0x2003             MOVS     R0,#+3
   \       0x38   0x.... 0x....      BL       leftmotor
    551                  rightmotor(1);
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x.... 0x....      BL       rightmotor
    552                  break;
   \       0x42   0xE00B             B.N      ??motor_6
    553              case RIGHT:
    554                  leftmotor(1);
   \                     ??motor_4: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x.... 0x....      BL       leftmotor
    555                  rightmotor(3);
   \       0x4A   0x2003             MOVS     R0,#+3
   \       0x4C   0x.... 0x....      BL       rightmotor
    556                  break;
   \       0x50   0xE004             B.N      ??motor_6
    557              case STOP:
    558                  motorstop();
   \                     ??motor_3: (+1)
   \       0x52   0x.... 0x....      BL       motorstop
    559                  break;
   \       0x56   0xE001             B.N      ??motor_6
    560              default:
    561                  motorstop();
   \                     ??motor_5: (+1)
   \       0x58   0x.... 0x....      BL       motorstop
    562                  break;
    563              }
    564          }
   \                     ??motor_6: (+1)
   \       0x5C   0xBD01             POP      {R0,PC}
    565          
    566          //갈림길 선택지 기록 초기화

   \                                 In section .text, align 2, keep-with-next
    567          void pathInit()
    568          {
    569              for (int i = 0; i < MAXCROSS; i ++)
   \                     pathInit: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0xE010             B.N      ??pathInit_0
    570              {
    571                  visitPath[i].direction = STOP;
   \                     ??pathInit_1: (+1)
   \        0x4   0x2104             MOVS     R1,#+4
   \        0x6   0x.... 0x....      LDR.W    R2,??DataTable22_16
   \        0xA   0x2305             MOVS     R3,#+5
   \        0xC   0xFB03 0xF300      MUL      R3,R3,R0
   \       0x10   0x54D1             STRB     R1,[R2, R3]
    572                  visitPath[i].visit = 0;
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x.... 0x....      LDR.W    R2,??DataTable22_16
   \       0x18   0x2305             MOVS     R3,#+5
   \       0x1A   0xFB03 0xF300      MUL      R3,R3,R0
   \       0x1E   0x441A             ADD      R2,R2,R3
   \       0x20   0xF8C2 0x1001      STR      R1,[R2, #+1]
    573              }   
   \       0x24   0x1C40             ADDS     R0,R0,#+1
   \                     ??pathInit_0: (+1)
   \       0x26   0x280A             CMP      R0,#+10
   \       0x28   0xDBEC             BLT.N    ??pathInit_1
    574          }
   \       0x2A   0x4770             BX       LR
    575          
    576          //최근 선택한 갈림길의 방향을 추가함

   \                                 In section .text, align 2, keep-with-next
    577          void addPath(enum Direction dir)
    578          {
   \                     addPath: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    579              uint32_t pos;
    580              
    581              //최대 교차로 기록 횟수를 넘어설 때의 예외처리
    582              if (visitPath[MAXCROSS - 1].visit == 1)
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable22_16
   \        0x8   0xF8D0 0x002E      LDR      R0,[R0, #+46]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??addPath_0
    583                  pathInit();
   \       0x10   0x.... 0x....      BL       pathInit
    584          
    585          
    586              //비어 있는, 가장 마지막의 갈림길 번호를 선택함
    587              for (int i = 0; i < MAXCROSS; i ++)
   \                     ??addPath_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x280A             CMP      R0,#+10
   \       0x18   0xDA0A             BGE.N    ??addPath_1
    588              {
    589                  if (visitPath[i].visit == 1)
   \       0x1A   0x.... 0x....      LDR.W    R1,??DataTable22_16
   \       0x1E   0x2205             MOVS     R2,#+5
   \       0x20   0xFB02 0xF200      MUL      R2,R2,R0
   \       0x24   0x4411             ADD      R1,R1,R2
   \       0x26   0xF8D1 0x1001      LDR      R1,[R1, #+1]
   \       0x2A   0x2901             CMP      R1,#+1
   \       0x2C   0xD100             BNE.N    ??addPath_2
    590                      pos = i;
   \       0x2E   0x0005             MOVS     R5,R0
    591                      break;
    592              }
    593          
    594              visitPath[pos].visit = 1;
   \                     ??addPath_2: (+1)
   \                     ??addPath_1: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable22_16
   \       0x36   0x2205             MOVS     R2,#+5
   \       0x38   0xFB02 0xF205      MUL      R2,R2,R5
   \       0x3C   0x4411             ADD      R1,R1,R2
   \       0x3E   0xF8C1 0x0001      STR      R0,[R1, #+1]
    595              visitPath[pos].direction = dir;
   \       0x42   0x.... 0x....      LDR.W    R1,??DataTable22_16
   \       0x46   0x2005             MOVS     R0,#+5
   \       0x48   0x4345             MULS     R5,R0,R5
   \       0x4A   0x554C             STRB     R4,[R1, R5]
    596          }
   \       0x4C   0xBD31             POP      {R0,R4,R5,PC}
    597          
    598          //제일 최근 선택된 갈림길의 선택을 제거함

   \                                 In section .text, align 2, keep-with-next
    599          void removePath()
    600          {
    601              for (int i = MAXCROSS - 1; i > -1; i --)
   \                     removePath: (+1)
   \        0x0   0x2109             MOVS     R1,#+9
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD419             BMI.N    ??removePath_0
    602              {
    603                  if (visitPath[i].visit == 1)
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable22_16
   \        0xA   0x2205             MOVS     R2,#+5
   \        0xC   0xFB02 0xF201      MUL      R2,R2,R1
   \       0x10   0x4410             ADD      R0,R0,R2
   \       0x12   0xF8D0 0x0001      LDR      R0,[R0, #+1]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD106             BNE.N    ??removePath_1
    604                      visitPath[i].direction = STOP;
   \       0x1A   0x2004             MOVS     R0,#+4
   \       0x1C   0x.... 0x....      LDR.W    R2,??DataTable22_16
   \       0x20   0x2305             MOVS     R3,#+5
   \       0x22   0xFB03 0xF301      MUL      R3,R3,R1
   \       0x26   0x54D0             STRB     R0,[R2, R3]
    605                      visitPath[i].visit = 0;
   \                     ??removePath_1: (+1)
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x.... 0x....      LDR.W    R3,??DataTable22_16
   \       0x2E   0x2005             MOVS     R0,#+5
   \       0x30   0x4341             MULS     R1,R0,R1
   \       0x32   0xEB03 0x0001      ADD      R0,R3,R1
   \       0x36   0xF8C0 0x2001      STR      R2,[R0, #+1]
    606                      break;
    607              }
    608          }
   \                     ??removePath_0: (+1)
   \       0x3A   0x4770             BX       LR
    609          
    610          //제일 최근 방문했던 갈림길의 선택지를 호출함

   \                                 In section .text, align 2, keep-with-next
    611          enum Direction getPath()
    612          {
    613              for (int i = MAXCROSS - 1; i > -1; i --)
   \                     getPath: (+1)
   \        0x0   0x2109             MOVS     R1,#+9
   \        0x2   0xE000             B.N      ??getPath_0
   \                     ??getPath_1: (+1)
   \        0x4   0x1E49             SUBS     R1,R1,#+1
   \                     ??getPath_0: (+1)
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD40F             BMI.N    ??getPath_2
    614              {
    615                  if (visitPath[i].visit == 1)
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable22_16
   \        0xE   0x2205             MOVS     R2,#+5
   \       0x10   0xFB02 0xF201      MUL      R2,R2,R1
   \       0x14   0x4410             ADD      R0,R0,R2
   \       0x16   0xF8D0 0x0001      LDR      R0,[R0, #+1]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD1F2             BNE.N    ??getPath_1
    616                      return visitPath[i].direction;
   \       0x1E   0x.... 0x....      LDR.W    R2,??DataTable22_16
   \       0x22   0x2005             MOVS     R0,#+5
   \       0x24   0x4341             MULS     R1,R0,R1
   \       0x26   0x5C50             LDRB     R0,[R2, R1]
   \       0x28   0xE7FF             B.N      ??getPath_3
    617              }
    618          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function "getPath"
   \                     ??getPath_2: (+1)
   \                     ??getPath_3: (+1)
   \       0x2A   0x4770             BX       LR
    619          
    620          //특정 번호의 갈림길에서 선택한 길을 호출함

   \                                 In section .text, align 2, keep-with-next
    621          enum Direction recallPath(uint32_t num)
    622          {
    623              if (visitPath[num].visit == 1)
   \                     recallPath: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable22_16
   \        0x4   0x2205             MOVS     R2,#+5
   \        0x6   0xFB02 0xF200      MUL      R2,R2,R0
   \        0xA   0x4411             ADD      R1,R1,R2
   \        0xC   0xF8D1 0x1001      LDR      R1,[R1, #+1]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD105             BNE.N    ??recallPath_0
    624                  return visitPath[num].direction;
   \       0x14   0x.... 0x....      LDR.W    R2,??DataTable22_16
   \       0x18   0x2105             MOVS     R1,#+5
   \       0x1A   0x4348             MULS     R0,R1,R0
   \       0x1C   0x5C10             LDRB     R0,[R2, R0]
   \       0x1E   0xE000             B.N      ??recallPath_1
    625              else
    626                  return STOP;
   \                     ??recallPath_0: (+1)
   \       0x20   0x2004             MOVS     R0,#+4
   \                     ??recallPath_1: (+1)
   \       0x22   0x4770             BX       LR
    627          }
    628          

   \                                 In section .text, align 2, keep-with-next
    629          int main() {
   \                     main: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    630              // LCD 관련 설정은 LCD_Init에 구현되어 있으므로 여기서 할 필요 없음
    631              SystemInit();
   \        0x2   0x.... 0x....      BL       SystemInit
    632              RCC_Configure();
   \        0x6   0x.... 0x....      BL       RCC_Configure
    633              GPIO_Configure();
   \        0xA   0x.... 0x....      BL       GPIO_Configure
    634              EXTI_config();
   \        0xE   0x.... 0x....      BL       EXTI_config
    635              USART1_Init();
   \       0x12   0x.... 0x....      BL       USART1_Init
    636              USART2_Init();
   \       0x16   0x.... 0x....      BL       USART2_Init
    637              InitHCSR04();
   \       0x1A   0x.... 0x....      BL       InitHCSR04
    638          
    639              NVIC_Configure();
   \       0x1E   0x.... 0x....      BL       NVIC_Configure
    640              
    641              pathInit();
   \       0x22   0x.... 0x....      BL       pathInit
    642              
    643              state = STOP;
   \       0x26   0x2004             MOVS     R0,#+4
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \       0x2C   0x7008             STRB     R0,[R1, #+0]
    644              motor();
   \       0x2E   0x.... 0x....      BL       motor
    645          
    646              //BT 명령어가 입력되지 않으면 구동되지 않음
    647                learningFlag = 1;
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable22_10
   \       0x38   0x6008             STR      R0,[R1, #+0]
    648          
    649          
    650              //학습 후 갈림길 선택지용
    651              int cross = 0;
   \       0x3A   0x2600             MOVS     R6,#+0
   \       0x3C   0xE009             B.N      ??main_0
    652          
    653              while(1) {      
    654                  //2개의 적외선 센서 사용 (직선이 발견되지 않으면 직진중)
    655                  uint32_t lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
    656                  uint32_t rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
    657          
    658                  //목적지 도착
    659                  if (lft == 0 && rgt == 0)
    660                  {
    661                      state = STOP;
   \                     ??main_1: (+1)
   \       0x3E   0x2004             MOVS     R0,#+4
   \       0x40   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \       0x44   0x7008             STRB     R0,[R1, #+0]
    662                      motor();
   \       0x46   0x.... 0x....      BL       motor
    663          
    664                      cross = 0;
   \       0x4A   0x2600             MOVS     R6,#+0
    665                      sendDataUART2(HALT);
   \       0x4C   0x2048             MOVS     R0,#+72
   \       0x4E   0x.... 0x....      BL       sendDataUART2
    666                  }
   \                     ??main_0: (+1)
   \       0x52   0x2101             MOVS     R1,#+1
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x58   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x5C   0x0004             MOVS     R4,R0
   \       0x5E   0x2104             MOVS     R1,#+4
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x64   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x68   0x0005             MOVS     R5,R0
   \       0x6A   0xEA55 0x0004      ORRS     R0,R5,R4
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD0E5             BEQ.N    ??main_1
    667                  //직진
    668                  else if (lft == 1 && rgt == 1)
   \       0x72   0x2C01             CMP      R4,#+1
   \       0x74   0xD108             BNE.N    ??main_2
   \       0x76   0x2D01             CMP      R5,#+1
   \       0x78   0xD106             BNE.N    ??main_2
    669                  {
    670                      state = UP;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \       0x80   0x7008             STRB     R0,[R1, #+0]
    671                      motor();
   \       0x82   0x.... 0x....      BL       motor
   \       0x86   0xE7E4             B.N      ??main_0
    672                  }
    673                  //좌회전
    674                  else if (lft == 0 && rgt == 1)
   \                     ??main_2: (+1)
   \       0x88   0x2C00             CMP      R4,#+0
   \       0x8A   0xD11F             BNE.N    ??main_3
   \       0x8C   0x2D01             CMP      R5,#+1
   \       0x8E   0xD11D             BNE.N    ??main_3
    675                  {
    676                      state = LEFT;
   \       0x90   0x2002             MOVS     R0,#+2
   \       0x92   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \       0x96   0x7008             STRB     R0,[R1, #+0]
    677                      motor();
   \       0x98   0x.... 0x....      BL       motor
   \       0x9C   0xE00B             B.N      ??main_4
    678          
    679                      //직진할 때까지 회전함
    680                      while(lft == 1 && rgt == 1)
    681                      {
    682                       lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \                     ??main_5: (+1)
   \       0x9E   0x2101             MOVS     R1,#+1
   \       0xA0   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0xA4   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0xA8   0x0004             MOVS     R4,R0
    683                       rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \       0xAA   0x2104             MOVS     R1,#+4
   \       0xAC   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0xB0   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0xB4   0x0005             MOVS     R5,R0
    684                      }
   \                     ??main_4: (+1)
   \       0xB6   0x2C01             CMP      R4,#+1
   \       0xB8   0xD101             BNE.N    ??main_6
   \       0xBA   0x2D01             CMP      R5,#+1
   \       0xBC   0xD0EF             BEQ.N    ??main_5
    685                      state = STOP;
   \                     ??main_6: (+1)
   \       0xBE   0x2004             MOVS     R0,#+4
   \       0xC0   0x.... 0x....      LDR.W    R1,??DataTable22_9
   \       0xC4   0x7008             STRB     R0,[R1, #+0]
    686                      motor();
   \       0xC6   0x.... 0x....      BL       motor
   \       0xCA   0xE7C2             B.N      ??main_0
    687                  }
    688                  //우회전
    689                  else if (lft == 1 && rgt == 0)
   \                     ??main_3: (+1)
   \       0xCC   0x2C01             CMP      R4,#+1
   \       0xCE   0xD11B             BNE.N    ??main_7
   \       0xD0   0x2D00             CMP      R5,#+0
   \       0xD2   0xD119             BNE.N    ??main_7
    690                  {
    691                      state = RIGHT;
   \       0xD4   0x2003             MOVS     R0,#+3
   \       0xD6   0x....             LDR.N    R1,??DataTable22_9
   \       0xD8   0x7008             STRB     R0,[R1, #+0]
    692                      motor();
   \       0xDA   0x.... 0x....      BL       motor
   \       0xDE   0xE009             B.N      ??main_8
    693          
    694                      while(lft == 1 && rgt == 1)
    695                      {
    696                       lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \                     ??main_9: (+1)
   \       0xE0   0x2101             MOVS     R1,#+1
   \       0xE2   0x....             LDR.N    R0,??DataTable22
   \       0xE4   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0xE8   0x0004             MOVS     R4,R0
    697                       rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \       0xEA   0x2104             MOVS     R1,#+4
   \       0xEC   0x....             LDR.N    R0,??DataTable22
   \       0xEE   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0xF2   0x0005             MOVS     R5,R0
    698                      }
   \                     ??main_8: (+1)
   \       0xF4   0x2C01             CMP      R4,#+1
   \       0xF6   0xD101             BNE.N    ??main_10
   \       0xF8   0x2D01             CMP      R5,#+1
   \       0xFA   0xD0F1             BEQ.N    ??main_9
    699                      state = STOP;
   \                     ??main_10: (+1)
   \       0xFC   0x2004             MOVS     R0,#+4
   \       0xFE   0x....             LDR.N    R1,??DataTable22_9
   \      0x100   0x7008             STRB     R0,[R1, #+0]
    700                      motor();
   \      0x102   0x.... 0x....      BL       motor
   \      0x106   0xE7A4             B.N      ??main_0
    701                  }
    702                  //왼쪽 샛길 (갈림길이므로 학습 유무 체크함)
    703                  else if (lft == 0 && rgt == 1)
   \                     ??main_7: (+1)
   \      0x108   0x2C00             CMP      R4,#+0
   \      0x10A   0xD159             BNE.N    ??main_11
   \      0x10C   0x2D01             CMP      R5,#+1
   \      0x10E   0xD157             BNE.N    ??main_11
    704                  {
    705                      if (visitPath[0].visit == 1)
   \      0x110   0x....             LDR.N    R0,??DataTable22_16
   \      0x112   0xF8D0 0x0001      LDR      R0,[R0, #+1]
   \      0x116   0x2801             CMP      R0,#+1
   \      0x118   0xD116             BNE.N    ??main_12
    706                      {
    707                          //갈림길에서 선택한 방향을 호출해 차체의 방향을 전환시킴
    708                          state = recallPath(cross++);
   \      0x11A   0x0030             MOVS     R0,R6
   \      0x11C   0x.... 0x....      BL       recallPath
   \      0x120   0x1C76             ADDS     R6,R6,#+1
   \      0x122   0x....             LDR.N    R1,??DataTable22_9
   \      0x124   0x7008             STRB     R0,[R1, #+0]
    709                          motor();
   \      0x126   0x.... 0x....      BL       motor
    710                          while(lft == 1 && rgt == 1)
   \                     ??main_13: (+1)
   \      0x12A   0x2C01             CMP      R4,#+1
   \      0x12C   0xD191             BNE.N    ??main_0
   \      0x12E   0x2D01             CMP      R5,#+1
   \      0x130   0xD18F             BNE.N    ??main_0
    711                          {
    712                           lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \      0x132   0x2101             MOVS     R1,#+1
   \      0x134   0x....             LDR.N    R0,??DataTable22
   \      0x136   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x13A   0x0004             MOVS     R4,R0
    713                           rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \      0x13C   0x2104             MOVS     R1,#+4
   \      0x13E   0x....             LDR.N    R0,??DataTable22
   \      0x140   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x144   0x0005             MOVS     R5,R0
   \      0x146   0xE7F0             B.N      ??main_13
    714                          }
    715                      }
    716                      else
    717                      {
    718                          //직진 중 좌측 샛길이 발견되었음
    719                          if (waybackFlag == 0)
   \                     ??main_12: (+1)
   \      0x148   0x....             LDR.N    R0,??DataTable22_11
   \      0x14A   0x6800             LDR      R0,[R0, #+0]
   \      0x14C   0x2800             CMP      R0,#+0
   \      0x14E   0xD118             BNE.N    ??main_14
    720                          {
    721                              //샛길로 이동하고 샛길을 선택지에 기록함
    722                              state = LEFT;
   \      0x150   0x2002             MOVS     R0,#+2
   \      0x152   0x....             LDR.N    R1,??DataTable22_9
   \      0x154   0x7008             STRB     R0,[R1, #+0]
    723                              addPath(LEFT);
   \      0x156   0x2002             MOVS     R0,#+2
   \      0x158   0x.... 0x....      BL       addPath
    724                              motor();
   \      0x15C   0x.... 0x....      BL       motor
    725                              while(lft == 1 && rgt == 1)
   \                     ??main_15: (+1)
   \      0x160   0x2C01             CMP      R4,#+1
   \      0x162   0xF47F 0xAF76      BNE.W    ??main_0
   \      0x166   0x2D01             CMP      R5,#+1
   \      0x168   0xF47F 0xAF73      BNE.W    ??main_0
    726                              {
    727                               lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \      0x16C   0x2101             MOVS     R1,#+1
   \      0x16E   0x....             LDR.N    R0,??DataTable22
   \      0x170   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x174   0x0004             MOVS     R4,R0
    728                               rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \      0x176   0x2104             MOVS     R1,#+4
   \      0x178   0x....             LDR.N    R0,??DataTable22
   \      0x17A   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x17E   0x0005             MOVS     R5,R0
   \      0x180   0xE7EE             B.N      ??main_15
    729                              }
    730                          }
    731          
    732                          //좌우 갈림길에서 우회전을 골랐을 경우임
    733                          //현재 차체의 좌측 샛길은 직진해온 길, 앞에 놓인 길은 좌우 갈림길의 좌측 길임
    734                          else
    735                          {
    736                              //좌측 길로 이동
    737                              state = UP;
   \                     ??main_14: (+1)
   \      0x182   0x2000             MOVS     R0,#+0
   \      0x184   0x....             LDR.N    R1,??DataTable22_9
   \      0x186   0x7008             STRB     R0,[R1, #+0]
    738          
    739                              //좌측을 선택하도록 선택지 업데이트함
    740                              removePath();
   \      0x188   0x.... 0x....      BL       removePath
    741                              addPath(LEFT);
   \      0x18C   0x2002             MOVS     R0,#+2
   \      0x18E   0x.... 0x....      BL       addPath
    742                              motor();
   \      0x192   0x.... 0x....      BL       motor
   \      0x196   0xE009             B.N      ??main_16
    743                              while(lft == 1 && rgt == 1)
    744                              {
    745                               lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \                     ??main_17: (+1)
   \      0x198   0x2101             MOVS     R1,#+1
   \      0x19A   0x....             LDR.N    R0,??DataTable22
   \      0x19C   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x1A0   0x0004             MOVS     R4,R0
    746                               rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \      0x1A2   0x2104             MOVS     R1,#+4
   \      0x1A4   0x....             LDR.N    R0,??DataTable22
   \      0x1A6   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x1AA   0x0005             MOVS     R5,R0
    747                              }
   \                     ??main_16: (+1)
   \      0x1AC   0x2C01             CMP      R4,#+1
   \      0x1AE   0xD101             BNE.N    ??main_18
   \      0x1B0   0x2D01             CMP      R5,#+1
   \      0x1B2   0xD0F1             BEQ.N    ??main_17
    748                              state = STOP;
   \                     ??main_18: (+1)
   \      0x1B4   0x2004             MOVS     R0,#+4
   \      0x1B6   0x....             LDR.N    R1,??DataTable22_9
   \      0x1B8   0x7008             STRB     R0,[R1, #+0]
    749                              motor();
   \      0x1BA   0x.... 0x....      BL       motor
   \      0x1BE   0xE748             B.N      ??main_0
    750                          }
    751                      }
    752                      
    753                      
    754                  }
    755                  //오른쪽 샛길
    756                  else if (lft == 1 && rgt == 0)
   \                     ??main_11: (+1)
   \      0x1C0   0x2C01             CMP      R4,#+1
   \      0x1C2   0xD157             BNE.N    ??main_19
   \      0x1C4   0x2D00             CMP      R5,#+0
   \      0x1C6   0xD155             BNE.N    ??main_19
    757                  {
    758                      if (visitPath[0].visit == 1)
   \      0x1C8   0x....             LDR.N    R0,??DataTable22_16
   \      0x1CA   0xF8D0 0x0001      LDR      R0,[R0, #+1]
   \      0x1CE   0x2801             CMP      R0,#+1
   \      0x1D0   0xD118             BNE.N    ??main_20
    759                      {
    760                          state = recallPath(cross++);
   \      0x1D2   0x0030             MOVS     R0,R6
   \      0x1D4   0x.... 0x....      BL       recallPath
   \      0x1D8   0x1C76             ADDS     R6,R6,#+1
   \      0x1DA   0x....             LDR.N    R1,??DataTable22_9
   \      0x1DC   0x7008             STRB     R0,[R1, #+0]
    761                          motor();
   \      0x1DE   0x.... 0x....      BL       motor
    762                          while(lft == 1 && rgt == 1)
   \                     ??main_21: (+1)
   \      0x1E2   0x2C01             CMP      R4,#+1
   \      0x1E4   0xF47F 0xAF35      BNE.W    ??main_0
   \      0x1E8   0x2D01             CMP      R5,#+1
   \      0x1EA   0xF47F 0xAF32      BNE.W    ??main_0
    763                          {
    764                           lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \      0x1EE   0x2101             MOVS     R1,#+1
   \      0x1F0   0x....             LDR.N    R0,??DataTable22
   \      0x1F2   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x1F6   0x0004             MOVS     R4,R0
    765                           rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \      0x1F8   0x2104             MOVS     R1,#+4
   \      0x1FA   0x....             LDR.N    R0,??DataTable22
   \      0x1FC   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x200   0x0005             MOVS     R5,R0
   \      0x202   0xE7EE             B.N      ??main_21
    766                          }
    767                      }
    768                      else
    769                      {
    770                          if (waybackFlag == 0)
   \                     ??main_20: (+1)
   \      0x204   0x....             LDR.N    R0,??DataTable22_11
   \      0x206   0x6800             LDR      R0,[R0, #+0]
   \      0x208   0x2800             CMP      R0,#+0
   \      0x20A   0xD118             BNE.N    ??main_22
    771                          {
    772                              state = RIGHT;
   \      0x20C   0x2003             MOVS     R0,#+3
   \      0x20E   0x....             LDR.N    R1,??DataTable22_9
   \      0x210   0x7008             STRB     R0,[R1, #+0]
    773                              addPath(RIGHT);
   \      0x212   0x2003             MOVS     R0,#+3
   \      0x214   0x.... 0x....      BL       addPath
    774                              motor();
   \      0x218   0x.... 0x....      BL       motor
    775                              while(lft == 1 && rgt == 1)
   \                     ??main_23: (+1)
   \      0x21C   0x2C01             CMP      R4,#+1
   \      0x21E   0xF47F 0xAF18      BNE.W    ??main_0
   \      0x222   0x2D01             CMP      R5,#+1
   \      0x224   0xF47F 0xAF15      BNE.W    ??main_0
    776                              {
    777                               lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \      0x228   0x2101             MOVS     R1,#+1
   \      0x22A   0x....             LDR.N    R0,??DataTable22
   \      0x22C   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x230   0x0004             MOVS     R4,R0
    778                               rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \      0x232   0x2104             MOVS     R1,#+4
   \      0x234   0x....             LDR.N    R0,??DataTable22
   \      0x236   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x23A   0x0005             MOVS     R5,R0
   \      0x23C   0xE7EE             B.N      ??main_23
    779                              }
    780                          }
    781                          else
    782                          {
    783                              state = UP;
   \                     ??main_22: (+1)
   \      0x23E   0x2000             MOVS     R0,#+0
   \      0x240   0x....             LDR.N    R1,??DataTable22_9
   \      0x242   0x7008             STRB     R0,[R1, #+0]
    784                              removePath();
   \      0x244   0x.... 0x....      BL       removePath
    785                              addPath(RIGHT);
   \      0x248   0x2003             MOVS     R0,#+3
   \      0x24A   0x.... 0x....      BL       addPath
    786                              motor();
   \      0x24E   0x.... 0x....      BL       motor
    787                              while(lft == 1 && rgt == 1)
   \                     ??main_24: (+1)
   \      0x252   0x2C01             CMP      R4,#+1
   \      0x254   0xF47F 0xAEFD      BNE.W    ??main_0
   \      0x258   0x2D01             CMP      R5,#+1
   \      0x25A   0xF47F 0xAEFA      BNE.W    ??main_0
    788                              {
    789                               lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \      0x25E   0x2101             MOVS     R1,#+1
   \      0x260   0x....             LDR.N    R0,??DataTable22
   \      0x262   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x266   0x0004             MOVS     R4,R0
    790                               rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \      0x268   0x2104             MOVS     R1,#+4
   \      0x26A   0x....             LDR.N    R0,??DataTable22
   \      0x26C   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x270   0x0005             MOVS     R5,R0
   \      0x272   0xE7EE             B.N      ??main_24
    791                              }
    792                          }
    793                      }
    794                  }
    795                  //좌우 갈림길
    796                  else if (lft == 0 && rgt == 0)
   \                     ??main_19: (+1)
   \      0x274   0xEA55 0x0004      ORRS     R0,R5,R4
   \      0x278   0x2800             CMP      R0,#+0
   \      0x27A   0xF040 0x8087      BNE.W    ??main_25
    797                  {
    798                      if (visitPath[0].visit == 1)
   \      0x27E   0x....             LDR.N    R0,??DataTable22_16
   \      0x280   0xF8D0 0x0001      LDR      R0,[R0, #+1]
   \      0x284   0x2801             CMP      R0,#+1
   \      0x286   0xD118             BNE.N    ??main_26
    799                      {
    800                          state = recallPath(cross++);
   \      0x288   0x0030             MOVS     R0,R6
   \      0x28A   0x.... 0x....      BL       recallPath
   \      0x28E   0x1C76             ADDS     R6,R6,#+1
   \      0x290   0x....             LDR.N    R1,??DataTable22_9
   \      0x292   0x7008             STRB     R0,[R1, #+0]
    801                          motor();
   \      0x294   0x.... 0x....      BL       motor
    802                          while(lft == 1 && rgt == 1)
   \                     ??main_27: (+1)
   \      0x298   0x2C01             CMP      R4,#+1
   \      0x29A   0xF47F 0xAEDA      BNE.W    ??main_0
   \      0x29E   0x2D01             CMP      R5,#+1
   \      0x2A0   0xF47F 0xAED7      BNE.W    ??main_0
    803                          {
    804                           lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \      0x2A4   0x2101             MOVS     R1,#+1
   \      0x2A6   0x....             LDR.N    R0,??DataTable22
   \      0x2A8   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x2AC   0x0004             MOVS     R4,R0
    805                           rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \      0x2AE   0x2104             MOVS     R1,#+4
   \      0x2B0   0x....             LDR.N    R0,??DataTable22
   \      0x2B2   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x2B6   0x0005             MOVS     R5,R0
   \      0x2B8   0xE7EE             B.N      ??main_27
    806                          }
    807                      }
    808          
    809                      else
    810                      {
    811          
    812                          //좌우 갈림길을 처음으로 마주함
    813                          if (waybackFlag == 0)
   \                     ??main_26: (+1)
   \      0x2BA   0x....             LDR.N    R0,??DataTable22_11
   \      0x2BC   0x6800             LDR      R0,[R0, #+0]
   \      0x2BE   0x2800             CMP      R0,#+0
   \      0x2C0   0xD11C             BNE.N    ??main_28
    814                          {
    815                              state = LEFT;
   \      0x2C2   0x2002             MOVS     R0,#+2
   \      0x2C4   0x....             LDR.N    R1,??DataTable22_9
   \      0x2C6   0x7008             STRB     R0,[R1, #+0]
    816                              addPath(LEFT);
   \      0x2C8   0x2002             MOVS     R0,#+2
   \      0x2CA   0x.... 0x....      BL       addPath
    817                              motor();
   \      0x2CE   0x.... 0x....      BL       motor
   \      0x2D2   0xE009             B.N      ??main_29
    818                              while(lft == 1 && rgt == 1)
    819                              {
    820                               lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \                     ??main_30: (+1)
   \      0x2D4   0x2101             MOVS     R1,#+1
   \      0x2D6   0x....             LDR.N    R0,??DataTable22
   \      0x2D8   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x2DC   0x0004             MOVS     R4,R0
    821                               rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \      0x2DE   0x2104             MOVS     R1,#+4
   \      0x2E0   0x....             LDR.N    R0,??DataTable22
   \      0x2E2   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x2E6   0x0005             MOVS     R5,R0
    822                              }
   \                     ??main_29: (+1)
   \      0x2E8   0x2C01             CMP      R4,#+1
   \      0x2EA   0xD101             BNE.N    ??main_31
   \      0x2EC   0x2D01             CMP      R5,#+1
   \      0x2EE   0xD0F1             BEQ.N    ??main_30
    823                              state = STOP;
   \                     ??main_31: (+1)
   \      0x2F0   0x2004             MOVS     R0,#+4
   \      0x2F2   0x....             LDR.N    R1,??DataTable22_9
   \      0x2F4   0x7008             STRB     R0,[R1, #+0]
    824                              motor();
   \      0x2F6   0x.... 0x....      BL       motor
   \      0x2FA   0xE6AA             B.N      ??main_0
    825                          }
    826          
    827                          //좌측 혹은 우측 샛길을 이용했다가 되돌아온 경우임
    828                          else
    829                          {
    830                              uint32_t oldDir = getPath();
   \                     ??main_28: (+1)
   \      0x2FC   0x.... 0x....      BL       getPath
    831          
    832                              //좌측 샛길을 이용했을 경우
    833                              if (oldDir == LEFT)
   \      0x300   0x2802             CMP      R0,#+2
   \      0x302   0xD121             BNE.N    ??main_32
    834                              {
    835                                  //샛길이 아닌 직진경로로 차체 이동 후 '직진'으로 업데이트
    836                                  waybackFlag = 0;
   \      0x304   0x2000             MOVS     R0,#+0
   \      0x306   0x....             LDR.N    R1,??DataTable22_11
   \      0x308   0x6008             STR      R0,[R1, #+0]
    837                                  state = LEFT;
   \      0x30A   0x2002             MOVS     R0,#+2
   \      0x30C   0x....             LDR.N    R1,??DataTable22_9
   \      0x30E   0x7008             STRB     R0,[R1, #+0]
    838                                  removePath();
   \      0x310   0x.... 0x....      BL       removePath
    839                                  addPath(UP);
   \      0x314   0x2000             MOVS     R0,#+0
   \      0x316   0x.... 0x....      BL       addPath
    840                                  motor();
   \      0x31A   0x.... 0x....      BL       motor
   \      0x31E   0xE009             B.N      ??main_33
    841                                  while(lft == 1 && rgt == 1)
    842                                  {
    843                                   lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \                     ??main_34: (+1)
   \      0x320   0x2101             MOVS     R1,#+1
   \      0x322   0x....             LDR.N    R0,??DataTable22
   \      0x324   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x328   0x0004             MOVS     R4,R0
    844                                   rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \      0x32A   0x2104             MOVS     R1,#+4
   \      0x32C   0x....             LDR.N    R0,??DataTable22
   \      0x32E   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x332   0x0005             MOVS     R5,R0
    845                                  }
   \                     ??main_33: (+1)
   \      0x334   0x2C01             CMP      R4,#+1
   \      0x336   0xD101             BNE.N    ??main_35
   \      0x338   0x2D01             CMP      R5,#+1
   \      0x33A   0xD0F1             BEQ.N    ??main_34
    846                                  state = STOP;
   \                     ??main_35: (+1)
   \      0x33C   0x2004             MOVS     R0,#+4
   \      0x33E   0x....             LDR.N    R1,??DataTable22_9
   \      0x340   0x7008             STRB     R0,[R1, #+0]
    847                                  motor();
   \      0x342   0x.... 0x....      BL       motor
   \      0x346   0xE684             B.N      ??main_0
    848                              }
    849                              //우측 샛길을 이용했을 경우
    850                              else
    851                              {
    852                                  waybackFlag = 0;
   \                     ??main_32: (+1)
   \      0x348   0x2000             MOVS     R0,#+0
   \      0x34A   0x....             LDR.N    R1,??DataTable22_11
   \      0x34C   0x6008             STR      R0,[R1, #+0]
    853                                  state = RIGHT;
   \      0x34E   0x2003             MOVS     R0,#+3
   \      0x350   0x....             LDR.N    R1,??DataTable22_9
   \      0x352   0x7008             STRB     R0,[R1, #+0]
    854                                  removePath();
   \      0x354   0x.... 0x....      BL       removePath
    855                                  addPath(UP);
   \      0x358   0x2000             MOVS     R0,#+0
   \      0x35A   0x.... 0x....      BL       addPath
    856                                  motor();
   \      0x35E   0x.... 0x....      BL       motor
   \      0x362   0xE009             B.N      ??main_36
    857                                  while(lft == 1 && rgt == 1)
    858                                  {
    859                                   lft = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0);
   \                     ??main_37: (+1)
   \      0x364   0x2101             MOVS     R1,#+1
   \      0x366   0x....             LDR.N    R0,??DataTable22
   \      0x368   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x36C   0x0004             MOVS     R4,R0
    860                                   rgt = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2);
   \      0x36E   0x2104             MOVS     R1,#+4
   \      0x370   0x....             LDR.N    R0,??DataTable22
   \      0x372   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \      0x376   0x0005             MOVS     R5,R0
    861                                  }
   \                     ??main_36: (+1)
   \      0x378   0x2C01             CMP      R4,#+1
   \      0x37A   0xD101             BNE.N    ??main_38
   \      0x37C   0x2D01             CMP      R5,#+1
   \      0x37E   0xD0F1             BEQ.N    ??main_37
    862                                  state = STOP;
   \                     ??main_38: (+1)
   \      0x380   0x2004             MOVS     R0,#+4
   \      0x382   0x....             LDR.N    R1,??DataTable22_9
   \      0x384   0x7008             STRB     R0,[R1, #+0]
    863                                  motor();
   \      0x386   0x.... 0x....      BL       motor
   \      0x38A   0xE662             B.N      ??main_0
    864                              }
    865                          }
    866                      }   
    867                  }
    868                  else
    869                  {
    870                      waybackFlag = 0;
   \                     ??main_25: (+1)
   \      0x38C   0x2000             MOVS     R0,#+0
   \      0x38E   0x....             LDR.N    R1,??DataTable22_11
   \      0x390   0x6008             STR      R0,[R1, #+0]
    871                      state = STOP;
   \      0x392   0x2004             MOVS     R0,#+4
   \      0x394   0x....             LDR.N    R1,??DataTable22_9
   \      0x396   0x7008             STRB     R0,[R1, #+0]
    872                      motor();
   \      0x398   0x.... 0x....      BL       motor
   \      0x39C   0xE659             B.N      ??main_0
    873                  }
    874          
    875              }
    876          
    877              return 0;
                     ^
Warning[Pe111]: statement is unreachable
    878          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \        0x0   0x4001'1400        DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0x4001'0800        DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x4001'3800        DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \        0x0   0x4000'4400        DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \        0x0   0x....'....        DC32     dist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \        0x0   0x....'....        DC32     state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \        0x0   0x....'....        DC32     learningFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_11:
   \        0x0   0x....'....        DC32     waybackFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_12:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_13:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_14:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_15:
   \        0x0   0x....'....        DC32     startScan

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_16:
   \        0x0   0x....'....        DC32     visitPath

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   EXTI0_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
         8   -> GPIO_ResetBits
       8   EXTI2_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
         8   -> GPIO_ResetBits
      16   EXTI_config
        16   -> EXTI_Init
        16   -> GPIO_EXTILineConfig
       8   EnableHCSR04PeriphClock
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
       8   GPIO_Configure
         8   -> GPIO_Init
       8   NVIC_Configure
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCC_Configure
         8   -> RCC_AHBPeriphClockCmd
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
       8   TIM3_IRQHandler
         8   -> GPIO_ResetBits
         8   -> HCSR04GetDistance
         8   -> TIM_ClearITPendingBit
         8   -> TIM_GetITStatus
       8   USART1_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> sendDataUART2
      24   USART1_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       8   USART2_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> sendDataUART1
         8   -> setCMD
      24   USART2_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       0   __NVIC_EnableIRQ
      16   addPath
        16   -> pathInit
       0   getPath
       8   leftmotor
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
      16   main
        16   -> EXTI_config
        16   -> GPIO_Configure
        16   -> GPIO_ReadInputDataBit
        16   -> InitHCSR04
        16   -> NVIC_Configure
        16   -> RCC_Configure
        16   -> SystemInit
        16   -> USART1_Init
        16   -> USART2_Init
        16   -> addPath
        16   -> getPath
        16   -> motor
        16   -> pathInit
        16   -> recallPath
        16   -> removePath
        16   -> sendDataUART2
       8   motor
         8   -> leftmotor
         8   -> motorstop
         8   -> rightmotor
       8   motorstop
         8   -> GPIO_ResetBits
       0   pathInit
       0   recallPath
       0   removePath
       8   rightmotor
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   sendDataUART1
         8   -> USART_SendData
       8   sendDataUART2
         8   -> USART_SendData
      32   setCMD
        32   -> __aeabi_memcpy4
        32   -> sendDataUART2
      48   startBT
        48   -> __aeabi_memcpy4
        48   -> sendDataUART2


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
      24  ?_0
      12  ?_1
      16  ?_2
      16  ?_3
      24  ?_4
      24  ?_5
     126  EXTI0_IRQHandler
     126  EXTI2_IRQHandler
      76  EXTI_config
      28  EnableHCSR04PeriphClock
     412  GPIO_Configure
     180  NVIC_Configure
      82  RCC_Configure
     152  TIM3_IRQHandler
      46  USART1_IRQHandler
      76  USART1_Init
      58  USART2_IRQHandler
      76  USART2_Init
      30  __NVIC_EnableIRQ
      78  addPath
       4  dist
      44  getPath
       4  learningFlag
     104  leftmotor
     926  main
      94  motor
      84  motorstop
      44  pathInit
      36  recallPath
      60  removePath
      66  rightmotor
      16  sendDataUART1
      16  sendDataUART2
     282  setCMD
      74  startBT
      12  startScan
      24  startup
       1  state
      52  visitPath
       4  waybackFlag

 
    64 bytes in section .bss
    37 bytes in section .data
   116 bytes in section .rodata
 3'468 bytes in section .text
 
 3'468 bytes of CODE  memory
   116 bytes of CONST memory
   101 bytes of DATA  memory

Errors: none
Warnings: 2
